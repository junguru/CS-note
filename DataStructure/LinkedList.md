# List
자료를 선형으로, 순서대로 저장하는 자료구조

일반적으로 배열 리스트 또는 연결 리스트로 구현


### 배열 리스트
* 원소가 메모리 상에 순차적으로 저장
* 논리적 저장 순서와 물리적 저장 순서가 일치
* `peek (random access)` 연산이 인덱스 기반으로 빠름
* 배열의 크기에 의해 가질 수 있는 원소의 크기가 제한됨 
* 삽입/삭제 동작 시 순서 유지 위해 `O(N)` 연산이 필요

### 연결 리스트
* 원소의 저장 위치가 논리적 순서와 다를 수 있음.
* 각 요소가 원소와 함께 다음 원소의 위치를 포함
* 최대 원소 수가 고정되지 않음
* 삽입/삭제 연산 `O(1)` - 순서 유지를 위해 원소를 한 칸씩 이동해줄 필요 없이 포인터만 수정
* 배열 리스트에 비해 구현이 복잡
* 탐색 연산 `O(N)`- 위치 인덱스 없이 head 포인터에서 순차적으로 탐색 시작하므로

<br/><br/>

# 여러 구현 variants
### 원형 연결 리스트

* 큐의 구현이 용이함 - front, rear 두 포인터 유지하지 않아도 큐 구현 가능
* 원형이므로 rear 노드에서 front 노드 접근 가능하므로
* 어떤 노드에서 시작해도 모든 노드를 순회하는 것이 가능
* 요소들이 순차적으로 반복하며 접근되어야 하는 경우 - OS의 태스크 스케쥴링, 메모리 관리, 파일 관리 등
* 한계 : 어디가 끝 노드인지 판단하기 어려움. 애초에 원형이기에 끝 자체가 존재하지 않음. 

### 이중 연결 리스트 (이전 노드 접근 가능)

* 리스트를 변형하기 용이하고 유연성이 높음
    * 특정 위치 요소를 삭제하고자 하는 경우, 단순 연결 리스트는 `cur`, `prev` 위해 전체 탐색 필요하지만, 이중은 양방향 접근 가능하므로 순회 안해도 됨. 즉, 구현 편의성 좋음
    * 양 끝 위치의 삽입 삭제가 편리하다. 단방향 연결 리스트는 마지막 요소 삭제 위해 `O(n)` 순회 필요. 양방향은 `prev` 통해 바로 접근 가능
* `prev` 포인터 사용하는 만큼 추가 메모리 필요
* 각 동작이 next 뿐만 아니라 `prev`도 수정하는 동작 필요하므로 오버헤드가 존재


### 더미 헤드
구현 편의성을 높인다. 삽입/삭제 시 기존은 리스트가 빈 경우를 별도로 구현해야 하지만 더미 노드가 있는 경우 항상 중간 노드를 삽입/삭제하는 것으로 구현 가능.


