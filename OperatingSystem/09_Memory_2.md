# Memory Management (2)

## Paging
### basic method
* 물리 메모리를 고정 크기의 **frame** 단위로 분할
* 논리 메모리를 같은 크기의 **page** 단위로 분할
* **MMU**가 **페이지 테이블**을 참조해 논리 주소를 물리 주소로 변환
* 논리 주소 공간과 물리 주소 공간을 완전히 분리함
    * 물리 메모리보다 큰 프로그램을 실행 가능
* 각 프로세스별로 독립된 논리 주소 공간과 페이지 테이블을 가짐
* `frame table`
    * OS가 전체 프레임에 대한 정보를 관리하기 위한 자료구조
    * 어떤 프레임이 가용한지, 할당되었는지, 총 프레임 개수 등 정보
    * 윈도우의 PFN, 리눅스의 mem map 등
* `page table`
    * 각 프로세스의 논리 주소 공간에서 물리 주소 공간으로의 번역
    * 논리 주소 $[p,d]$의 페이지 넘버 p를 인덱스로 페이지 테이블 접근
    * 페이지 테이블에서 $f$를 얻어 물리 주소 $[f,d]$로 번역
    * 각 프로세스의 PCB가 페이지 테이블에 대한 포인터를 가짐

#### internal fragmentation 문제
* 페이지 단위로 프로세스에 메모리를 할당
* 프로세스가 필요한 메모리 양과 페이지 크기가 맞아 떨어지지 않으면 마지막 프레임은 공간이 남게 됨
* 평균적으로 프로세스 당 0.5개의 페이지가 내부 단편화됨
* 메모리 낭비를 줄이고자 페이지 크기를 줄인다면 페이지 테이블의 크기가 커지는 오버헤드 발생

#### benefits of logical memory
* 프로그래머의 관점에서 물리 메모리를 완벽하게 분리함
    * 프로그램 하나만 있는 논리적인 메모리 공간
* 메모리 접근 작업이 단순해짐
* 실제 물리 메모리 변환은 하드웨어가 자동으로 조정

<br/>

### HW Support
#### Page Table을 레지스터에 저장한다면?
* 프로세스마다 다른 페이지 테이블 사용하므로, 문맥 교환 시 많은 레지스터 교환해야 함
* 일반적으로 페이지 테이블의 크기가 크기 때문에, 다음의 방식을 사용함

#### PTBR (Page Table Base Register)
* 메모리에 저장된 페이지 테이블의 시작 주소를 저장하는 레지스터
* 문맥 교환 시 PTBR의 값을 대상 프로세스의 PCB에 있는 페이지 테이블 포인터 주소로 변경

#### TLB (Translation Lookaside Buffer)
* 메모리에 저장된 페이지 테이블에 접근하는 것은 시간이 오래 걸린다
    * 먼저 메모리에 있는 페이지 테이블에 접근
    * 페이지 테이블을 통해 얻은 물리 주소에 한번 더 접근
    * 총 두 번의 메모리 접근이 필요!
* 대신 페이지 테이블 엔트리에 대한 캐시인 TLB를 유지
    * TLB hit : 얻은 페이지 테이블 엔트리를 통해 메모리 한번만 접근
    * TLB miss (**page fault**) : 메모리 상의 페이지 테이블에 접근해 프레임 주소를 얻고 TLB 갱신. 총 2번 메모리 접근
* associative : 페이지 번호를 TLB의 모든 키 값과 동시에 비교함
* TLB는 크기가 매우 작은 대신 (32~1024 엔트리), instruction 파이프라인에 포함되어 성능에 손실이 없음
* 여러 계층의 캐시를 사용하는 것처럼, 다계층 TLB를 구성할 수 있음
* TLB가 꽉 찬 경우 LRU, RR 등 정책 사용. 중요한 커널 엔트리는 대체 불가능하도록 wired-down 되기도 함.
* 문맥 교환 시 프로세스가 전환되므로 TLB를 초기화해야 함
    * TLB를 초기화 하는 대신 **ASID**를 TLB 엔트리에 포함
    * ASID를 통해 TLB 엔트리가 자신의 프로세스에 속하는지 판단해 주소 변환

#### PTLR (Page Table Length Register)
* 프로세스는 보통 자신의 논리 주소 공간 중의 일부만 사용함
* 사용하지도 않을 페이지 테이블을 메모리에 유지하는 것은 낭비임
* 대신 PTLR에 페이지 테이블의 크기를 저장해, 논리 주소가 올바른 범위에 접근하는지 검사

<br/>

### memory protection
* 각 프레임에 대한 보호 비트를 설정해 메모리를 보호
* 페이지 테이블 엔트리에 보호 비트를 추가해 저장
* 프레임이 read-only 인지 read-write 가능인지 보호 비트로 나타냄
* valid-invalid 비트를 통해 논리 주소 공간 범위를 벗어난 페이지를 표시

<br/>

### shared pages
* 코드가 변경되지 않는 **공유 라이브러리**를 물리 메모리에 하나만 유지
    * C언어에서 유닉스/리눅스 시스템 콜 제공하는 libc 라이브러리 등
    * 공유되기 위해서는 코드가 변경되지 않아야 함 (**reentrant**)
* 프로세스별 페이지 테이블에 동일한 주소로 매핑해 라이브러리를 공유함

<br/>
<br/>

## Page Table Structure
* 큰 논리 주소 공간을 지원하니, 페이지 테이블이 커지는 문제를 해결해야 함

### hierarchical paging
* page offset과 page number 중 page number를 나누어 여러 계층으로 페이지 테이블 순회

### hashed page tables
* page number에 대한 해시 함수 값을 인덱스로 가지는 clustered 해시 테이블
* 해시 테이블의 엔트리는 해시 값이 같은 페이지 테이블 엔트리의 연결 리스트

### inverted page tables
* 모든 프로세스에 대해 페이지 테이블을 유지하면 메모리 사용량이 큼
* 대신 가상 메모리의 페이지가 아닌, 물리 메모리의 프레임에 대해 엔트리를 가지는 **하나의 테이블**만 유지
* 테이블의 각 엔트리는
    * 프레임을 소유한 가상 페이지의 주소
    * 프레임을 소유한 프로세스의 정보 (pid, ASID)
* 페이지 참조 시 **검색 시간**이 클 수 있음 (물리 주소로 정렬되어 있기 때문)
    * **해시** 테이블을 사용해 검색 속도를 향상
* 공유 라이브러리 등 **메모리 공유** 시 page fault가 발생함


<br/>
<br/>

## Swapping
* 메모리 상의 프로세스를 일시적으로 저장장치로 내보내는 과정
    * 일반적인 보조 저장장치보다 빠른 스토리지인 backing storage
* 전통적인 스왑 방식 : 전체 프로세스를 내보내는 방식
    * 실제 물리 메모리보다 많은 양의 프로세스를 시스템이 유지할 수 있음
    * 전체 프로세스를 저장장치로 옮기는 비용이 상당함
* 현대적인 스왑 방식 : 프로세스 전체 대신 일부 페이지를 스왑
    * 페이지 단위로 내보내므로, page out, page in 용어를 사용
* 모바일 시스템의 스왑 방식
    * 가용 메모리가 특정 임계값 밑으로 내려가면, 앱들에게 메모리 해제를 요청하거나 종료시킴
    * 앱이 해제한 메모리는 플래시 메모리에 저장된 후 추후 복원됨