# CPU Scheduling
* 성능 향상, 반응성 향상 등의 이점을 위해 여러 스레드를 병렬 실행
* CPU 코어를 어떤 프로세스에 할당할지를 결정하는 알고리즘
* 실제 시스템에서는 커널 레벨 스레드를 스케줄링함

<br/>

## 기본 개념
### IO burst & CPU burst
* `cpu burst` : cpu를 통한 계산
* `io burst` : IO 수행을 위해 프로세스가 대기
* 프로세스의 동작은 cpu-burst와 io-burst의 반복으로 구성됨
* 프로세스에서 cpu-burst와 io-burst의 구성 비율을 이용해 스케줄링

### 스케줄링 시점
1. 프로세스가 IO 요청 등으로 대기 상태로 진입
2. 인터럽트가 발생해 ready 상태로 진입
3. IO가 완료되어 대기 상태에서 ready 상태로 진입
4. 프로세스가 종료될 때

* 1번과 4번의 경우 선택의 여지가 없이 다른 새로운 프로세스를 할당해 수행
* 2번과 3번의 경우 기존 프로세스를 계속 수행하거나, 새로운 프로세스를 실행하기를 선택

### 선점 & 비선점 스케줄링
#### non-preemptive
* 종료하거나 대기 상태에 진입하는 등 프로세스가 스스로 자원 해제할때까지 점유

#### preemptive
* 대부분 OS가 선점 스케줄링 사용함
* 공유 데이터 접근 중인 프로세스 선점 시 일관성 문제 발생 가능
* 커널 모드에서 중요한 커널 데이터를 수정 중 선점된다면 시스템 에러 발생 가능
    * 대부분의 시스템에서는 선점 커널 방식과 동시에  mutex lock 등의 기법을 통해 경쟁 조건을 방지
* OS의 중요한 작업을 수행하는 코드 수행 중 인터럽트 발생 문제
    * 코드에 진입할 때 인터럽트를 무효화하고 완료 시 다시 발생시킴

### dispatcher
* 스케줄러가 선택한 프로세스에게 CPU 코어의 제어를 넘기는 모듈
* Context Switch 할때마다 호출
* 자발적 문맥 교환
    * IO 대기 등 현재 가용하지 않은 자원 요청
* 비자발적 문맥 교환
    * 선점에 의해 CPU 코어를 빼앗긴 경우

<br/>

## 스케줄링 기준
* **cpu utilization** : 가능한 CPU를 바쁘게 활용해야 함
* **throughput** : 단위 시간 당 완료한 프로세스의 수
* **turnaround time** : 단일 프로세스 실행에 소요되는 시간
* **waiting time** : 프로세스가 ready 큐에서 기다리는 총 시간
* **response time** : 첫 응답이 시작되기까지 걸리는 시간

<br/>

## 스케줄링 알고리즘
### FCFS (first come first served)
* 먼저 CPU를 요청한 프로세스에게 할당
* 비선점 스케줄링 알고리즘
* 준비 큐를 PCB들을 연결한 FIFO 큐로 구현
    * 프로세스가 준비 큐에 진입 시 tail에 PCB를 추가
    * head에 있는 프로세스에 CPU 코어를 할당
* CPU bound 프로세스가 CPU를 길게 할당하게 됨
    * IO bound 프로세스는 긴 시간동안 대기
    * CPU 및 자원 활용율이 떨어짐

### SJF
* 다음 CPU burst 길이가 가장 짧은 프로세스에 코어를 할당
* 최적의 평균 waiting time 성능을 보임
* 다만, 다음 CPU burst의 길이를 예측하는 것은 불가능함
    * 대신 다음 CPU burst를 이전 값들을 이용해 지수평균해 근사
* 선점, 비선점 구현 모두 가능
    * 선점의 경우 새로 들어온 프로세스의 다음 CPU burst가 더 짧으면 선점
    * 비선점의 경우 현재 프로세스가 자원 반환할 때까지 대기

### Round Robin
* FCFS 스케줄링에 선점 기능을 추가해 시간 단위마다 다른 프로세스로 교체
* 준비 큐를 원형 큐로 구현해 큐를 돌며 프로세스에 CPU를 시간 할당량만큼 할당
* 타이머를 통해 시간 할당량 이후 인터럽트 발생하도록 설정
* FCFS와 마찬가지로 프로세스의 평균 대기 시간이 길 수 있음
* 시간 할당량을 적당히 큰 크기로 설정
    * 시간 할당량이 너무 작다면 문맥 교환에 CPU를 낭비하게 될 것
    * 한 시간 할당량 내에 프로세스가 작업을 끝내도록 해 turnaround time 향상

### Priority Scheduling
* 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스에 CPU 코어를 할당
* 프로세스 우선순위 결정 방법
    * 시간제한, 메모리 사용, IO와 CPU 비율 등 정보
    * 혹은 비용, 비즈니스 로직 등 외부 정보 활용
* SJF와 마찬가지로 선점, 비선점 구현이 가능
* starvation(기아) 문제 발생할 수 있음
    * 장시간 대기 중인 프로세스의 우선순위를 점차 높이는 방법
    * 같은 우선순위일 경우 Round Robin 방식과 결합하는 방법


### Multilevel Queue
* 우선순위 스케줄링 방법을 이용
* 우선순위별로 다른 큐에 프로세스 PCB를 배치
    * 실시간 프로세스, 시스템 프로세스 등 중요도 높은 프로세스를 높은 우선순위 큐에 배치
* 어떤 큐의 프로세스를 선택할지 결정하는 스케줄링
    * 우선순위가 높은 큐에 프로세스가 들어오면 선점하는 방식
    * 혹은 큐별로 시간 할당량을 부여하는 방식 (높은 우선순위 큐가 더 긴 할당량)
* 각 큐 내부에서 프로세스를 선택하는 스케줄링 알고리즘을 큐마다 다르게 가질 수 있음