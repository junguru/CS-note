# Virtual Memory (2)

## Frame Allocation
* 가용한 프레임을 프로세스들에게 어떻게 할당할 것인가?

### Minimum Number of Frames
* 프로세스가 성능 저하 없이 실행될 수 있도록 최소 필요 수 이상 프레임이 할당되도록 보장해야 함
    * 할당된 프레임 수가 부족하다면 page fault가 자주 발생하게 됨
* 시스템이 지원하는 명령어 구조에 따라 최소 프레임 수가 정의됨

### Allocation Algorithms
* `equal`
    * 모든 프로세스에 같은 양의 프레임 할당
* `proportional`
    * 프로세스의 크기와 비례한 양의 프레임 할당
* `priority`
    * 프로세스의 우선순위가 높으면 더 많은 프레임 할당

### Global vs Local Alloction
* `global replacement`
    * 프로세스가 대체할 프레임을 전체 프레임 집합에서 선택
    * 좀 더 좋은 throughput을 보임
* `local replacement`
    * 프로세스가 대체할 프레임을 자신이 보유한 프레임 집합에서 선택
* `reaper`
    * 가용한 프레임 수가 임계치 이하로 떨어지면 커널 루틴 수행되어 모든 프로세스로부터 페이지 회수
    * LRU 근사 등을 통해 대체할 페이지 선택
    * 임계치를 유지할 수 없다면, 프로세스를 선택해 종료시켜 메모리 회수 (OOM killer)

### NUMA
* 특정 CPU가 특정 메모리에 빠르게 접근할 수 있는 NUMA 시스템
* 프로세스가 실행하는 CPU에 가능한 가까운 프레임을 할당
    * 각 프로세스가 마지막으로 실행된 CPU를 추적해야 함

<br/>
<br/>

## Thrashing
* 프로세스 실행보다 페이징에 더 많은 시간을 소비하게 되는 상황
    1. 프로세스에 충분한 프레임이 할당되지 않아 page fault 발생
    2. 모든 페이지가 활발히 사용되고 있었다면, 가져온 페이지가 곧 다시 내보내질 것임
    3. 결국 페이지가 대체되고 다시 적재되는 과정이 계속 반복됨
* CPU 활용률이 극도로 낮아지게 됨

### Cause of Thrashing
1. CPU 이용률이 낮으면, 시스템에서 다중 프로그래밍의 정도를 높임 (새 프로세스 추가)
2. 프로세스가 실행 중 요구하는 프레임의 수가 많아져, 다른 프로세스의 프레임을 빼앗아옴
3. 스왑 과정을 위해 페이징 장치를 대기해 준비 큐에 있는 프로세스의 수가 줄어듬
    * 스왑 과정 중 프로세스는 페이징 장치의 큐에서 대기
    * 페이징 장치 큐가 길어져 스래싱과 무관한 프로세스에서도 페이징 시간 길어짐
4. CPU 이용률이 저하되어 다시 1번이 반복됨

#### Locality Model
* 스래싱 해결을 위해, 프로세스가 **필요한 만큼** 프레임을 할당해야 함
* `locality` : 프로세스 실행 시 집중적으로 함께 참조되는 페이지의 집합
    * 프로세스 실행 시 한 메모리 구역을 반복되게 접근 함
    * 프로세스 전환 시 한 locality에서 다른 구역의 locality로 전환하는 것
* 지역성을 포함할 만큼 충분한 프레임을 프로세스에 할당해 스래싱 해결

### Working-Set Model
* **locality** 를 가정한 모델
* `working set` : 프로세스가 **최근에 접근**한 n개의 페이지의 집합
    * 활발하게 접근한 (지역성) 프레임이 working set에 포함될 것
    * 타이머 인터럽트와 접근 비트를 활용해 최근 접근한 페이지를 근사
* 모든 프로세스가 working set 크기에 맞는 충분한 프레임 할당
    * 할당되는 전체 양이 물리 메모리보다 크다면 프로세스를 선택해 중지

### Page Fault Frequency
* 스래싱이 나타나면 page fault의 비율 (PFF)가 높아지고, 이를 감지해 스래싱을 해결
* 프로세스 별 PFF의 임계값을 정해 프레임 조절
    * PFF가 높으면 프레임 추가 할당
    * PFF가 낮으면 프레임을 회수

### Common Practice
* 스래싱과 스왑은 성능에 큰 영향을 미치므로 가능한 피해야 함
* 메모리에 모든 working set을 유지할 만큼 충분한 물리 메모리를 제공하는 것이 중요

<br/>
<br/>

## Memory Compression
* 수정된 페이지를 스왑 공간으로 내보내는 대신, 여러 프레임을 단일 프레임으로 **압축**
* 스왑 공간 동작을 지원하지 않는 모바일 시스템에서 지원. 윈도우, 맥에서도 활용

### Example
* `free frame list` : 7, 2, 9, 21, 27, 16
* `modified frame list` : 15, 3, 35, 26
1. 변경된 프레임 15, 3, 35를 스왑 공간으로 내보내는 대신 압축해 7에 저장
2. 7을 가용 메모리에서 제거하고, 15, 3, 35는 가용 프레임 공간으로 이동할 수 있음
3. 셋 중 하나가 참조되면 page fault 발생. 압축 해제되어 세 페이지가 메모리로 복원됨

<br/>
<br/>

## Kernel Memory Allocation
1. 유저 프로세스 메모리
    * 커널에서 관리하는 free-frame list에서 프레임 할당
    * 고정 크기 프레임으로 할당하므로 내부 단편화 발생하기 쉬움
2. 커널 메모리 할당
    * **별개**의 free-memory pool에서 할당
    * 커널 코드와 데이터는 성능을 위해 **페이징 하지 않고** **보수적**으로 할당
    * 물리 메모리와 직접 상호작용하는 하드웨어가 존재해 물리적으로 연속된 위치에 메모리 존재해야 함

### buddy system
* 물리적으로 연속된 페이지로 이루어진 고정 크기 세그먼트 할당
* 2의 거듭제곱 개수 단위로 세그먼트를 할당
    * 버디를 반씩 나누어 작은 크기의 버디를 나누고 **합병하기 쉬움**
    * 고정 크기 버디를 할당하므로 **내부 단편화** 발생 가능함

### slab allocation
* `slab` : 하나 이상의 연속된 물리 페이지로 구성
* `cache` : 하나 이상의 슬랩으로 구성
1. 각 커널 객체(자료구조)가 하나의 캐시를 가짐
    * 세마포어, 파일 객체, process descriptor 등에 대한 캐시
2. 각 캐시는 캐시가 나타내는 자료구조의 인스턴스인 객체로 채워져 있음
3. 커널 자료구조의 객체가 새로 필요하면 캐시로부터 할당
* **내부 단편화**가 거의 발생하지 **않음**
* 객체가 미리 생성되어 있으므로 메모리가 **빠르게 할당**

<br/>
<br/>

## Prepaging
* 프로세스를 초기에 시작할 때 과도한 page fault가 발생하는 것을 방지
* 프로세스의 working set 페이지들을 한번에 메모리로 가져옴
* prepaging과 page fault 처리 비용을 비교해 적은 쪽을 선택

<br/>
<br/>

## Page Size
* 큰 페이지 사용 시 이점
    * 페이지 테이블 크기, page fault 비율
* 작은 페이지 사용 시 이점
    * 내부 단편화, 지역성, IO 시간
* 시스템이 발전하며 큰 페이지를 사용하는 것으로 발전하고 있음

<br/>
<br/>

## TLB Reach
* TLB를 통해 접근 가능한 메모리의 크기, 범위
    * TLB 엔트리의 수에 페이지 크기를 곱해서 얻을 수 있음
* TLB Reach가 프로세스의 **working set**을 모두 포함하면 효율적인 작업이 가능할 것임
* 페이지 크기 자체를 늘리거나, 다양한 페이지 크기를 지원해 TLB에서 많은 메모리 접근 가능하도록

<br/>
<br/>

## Efficient Programming with Demand Paging
```c
int i, j;
int[128][128] data;
for (i=0; i<128; i++)
    for (j=0; j<128; j++)
        data[i][j] = 0;

int i, j;
int[128][128] data;
for (j=0; j<128; j++)
    for (i=0; i<128; i++)
        data[i][j] = 0;    
```
* 메모리 상 인접해 있는 요소를 접근해 page fault 횟수를 감소
* 참조의 지역성을 높이는 메모리 접근
    * 같은 동작을 위해 해시 테이블을 사용하는 것보다 스택을 사용하는 것이 지역성이 좋음
* 탐색 속도, 메모리 참조 횟수, 페이지 접근 횟수 등 고려

<br/>
<br/>

## I/O Interlock & Page Locking
* 페이지가 메모리에 상주(lock)해야 하는 경우가 존재함
    * 사용자 메모리 공간으로 I/O가 발생하는 경우 등
    * 다른 프로세스에게 프레임을 빼앗긴 뒤 IO가 수행된다면 다른 프로세스의 메모리를 침범한 것임
* 각 프레임에 lock 비트를 추가해 lock되었다면 대체되지 않도록