# Threads
* CPU 코어의 기본 작업 단위. 하나의 프로세스가 여러 스레드를 포함
* 여러 스레드가 병렬로 실행하며 동시에 여러 작업을 수행

<br/>

## Process vs Thread
### shared resources
* code 영역의 프로그램 실행 코드
* data 영역의 정적 변수
* 파일 등의 OS 자원

### thread components
* 스레드 ID
* PC (program counter)
* Register Set
* stack 영역

### Benefits of Threading
* 프로세스와 달리 주소 공간을 공유해 쉬운 ITC
* 스레드 간 자원을 공유해 자원 사용량을 아낄 수 있음
* 프로세스에 비해 더 빠른 스레드 생성 및 Context Switch
* 동시에 여러 작업을 수행해 시스템 성능 및 유저 반응성 증가
* 정렬, 트리, 그래프 알고리즘 등의 효율적 구현에 스레드 활용 가능
* CPU intensive 작업을 스레드를 통해 병렬 수행

### Challenges in Threading
* 프로세스의 작업을 독립된 여러 작업으로 나누어지게 하는 영역을 찾아야 함
* 여러 작업 간 기여도가 균등하게 분배되어야 함
* 작업이 스레드로 분배되는 것처럼, 데이터도 코어들에 나누어 져야 함
* 여러 스레드에서 수행하는 작업 간 데이터 의존성, 일관성 문제
* 여러 스레드에서 병렬 수행되므로, 다양한 수행 경로가 존재해 디버깅, 테스팅이 어려움

### Parallelism Types
#### Data parallelism
* 데이터를 분배, 동일한 작업 수행
* 각 스레드(코어)가 분배된 데이터 조각에 대해 동일 연산 수행

#### Task parallelism
* 작업을 분배, 동일한 데이터
* 각 스레드(코어)가 데이터에 대해 분배된 연산 수행

<br/>

## Multithreading Models
### user thread vs kernel thread
#### user thread
* `user thread` : 커널 지원 없이 유저 레벨 라이브러리로 생성 및 관리되는 스레드
* 스레드 생성, Switching, 스레드 간 동기화가 커널 개입 없이 **프로시저 호출**로 이루어짐
* 유저 레벨 스레드의 장점
    * 프로세스의 주소 공간에서 작은 크기의 TCB (PC, 레지스터, 스택) **간단한 구조**로 이루어짐
    * 커널의 관여가 없어 스레드 관리가 용이함
    * 커널의 관여가 없어 스레드 생성, 전환 등의 **성능이 좋음**
* 유저 레벨 스레드의 단점
    * 프로세스를 커널 스레드에 매핑하므로 하나의 스레드가 IO 대기하면 전체 스레드가 **대기**함
    * 커널은 프로세스의 순서만 스케줄링을 수행함. 프로세스에 스레드가 1000개가 있든 1개가 있든 같은 시간을 할당해 비효율적인 스케줄 발생할 수 있음

#### kernel thread
* `kernel thread` : OS에서 관리하는 커널 스레드
* 모든 프로세스와 스레드를 커널(OS)가 생성 및 관리
    * 커널이 Thread Table과 Process Table을 유지
* 커널 레벨 스레드의 장점
    * 커널이 모든 스레드를 인지하고 있으므로, 많은 스레드를 가진 프로세스에 많은 CPU 시간을 할당하는 등 효율적인 스케줄링
    * 자주 block되는 응용에 대해 커널 레벨 스레드가 유용함
    * 한 프로세스 내의 여러 스레드를 각각 다른 코어에 스케줄 가능
* 커널 레벨 스레드의 단점
    * 유저 레벨 스레드에 비해 **느림**.
    * TCB를 통해 모든 스레드의 정보를 유지하는 오버헤드가 큼

#### why user-level thread needs mapping?
* 유저 레벨 스레드는 라이브러리를 통해 생성, 관리하므로 OS(커널)은 인지하지 못함
* 스레드 스케줄링은 커널에서 수행하므로 유저 스레드를 인지하기 위해 커널 스레드에 매핑이 필요함
* 커널 공간에 존재하는 프로세스(단일 스레드)로 매핑해 OS가 인지하고 스케줄할 수 있도록

### Many-to-One
* 여러 개의 유저 레벨 스레드를 하나의 커널 스레드로 매핑
* 한 번에 하나의 스레드만 커널에 접근 가능, 즉 스레드 **병렬 수행 불가**
* 만약 스레드가 시스템 콜이 커널에서 처리되기를 기다려야 한다면 전체 프로세스가 기다려야 함
* 스레드가 유저 공간에서 관리되므로 효율적이나, 멀티코어의 이점 활용하지 못함

### One-to-One
* 각 유저 레벨 스레드가 커널 스레드로 매핑됨
* 여러 스레드가 병렬로 수행될 수 있음. 멀티코어의 이점 활용됨
* 유저 스레드 생성 시 커널 스레드를 생성하는 오버헤드 존재
* 많은 커널 스레드의 수로 인해 시스템의 성능이 하락

### Many-to-Many
* 유저 스레드와 커널 스레드 간 다대다 매핑
* 일대일과 다대일 모델의 단점을 모두 보완한 절충 모델
    * 일대일 모델의 동시성의 이점, 다대일 모델의 원하는 만큼 유저 스레드 생성 이점 모두 가짐
    * 일대일 모델의 시스템 오버헤드, 다대일 모델의 동시성 문제를 보완함

<br/>

## Implicit Threading
* 스레드의 생성, 관리를 사용자가 아닌 컴파일러, 라이브러리에 넘김
    * 개발자가 병렬 수행 가능한 작업을 구분
    * 세부적 스레드 생성/관리는 동적 라이브러리가 수행
* implicit threading 예시
    * Thread Pools
    * Fork Join
    * OpenMP
    * apple GCD

<br/>

## Issues on Threading
### fork & exec
* fork 수행 시 모든 스레드를 복제해야 하는가?
* 보통 exec 수행 시 전체 프로세스를 대체

### signal handling
* 어떤 이벤트가 발생한 것을 프로세스에게 알리는 신호
* 프로세스에 시그널을 전달하는 여러 방식이 존재
    * 시그널을 야기시킨 스레드에게 전달하는 방법
    * 각 스레드가 받을 시그널과 받지 않을 시그널을 지정하는 방법
    * 프로세스의 모든 스레드에게 전달하는 방법 등

### thread cancellation
* 스레드가 완료되지 못하고 종료되어야 하는 경우
* 스레드가 공유 데이터를 갱신하는 중에는 취소가 안전하지 않음
* 취소된 스레드가 데이터를 아직 반환하지 않은 경우
* `asynchronous` : 스레드를 즉시 취소
* `deferred` : 스레드가 종료해도 안전한지 확인한 뒤 취소

### thread-local storage
* 각 스레드별로 사용해야 하는 데이터가 필요한 경우 TLS 사용
* 지역변수와 달리, 전체 함수 호출에 걸쳐 visible (정적 변수와 비슷한 개념)
* 자바의 `ThreadLocal<T>`, pthread의 타입 `pthread_key_t` 등

### scheduler activations
* 커널과 스레드 라이브러리 간 통신을 고려해야 함
* `LWP` (light weight process)
    * 커널 스레드와 유저 스레드 사이의 가상의 프로세스
    * 커널 스레드의 수를 동적으로 조절하며 성능을 유지