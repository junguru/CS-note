# Process
* cpu와 메모리, 파일 및 IO 등 장치를 할당받아 수행하는 작업의 단위
* 메모리에 올라와 실행 중인 프로그램
* 프로세스는 여러 코어에서 병렬로 실행되는 스레드들로 이루어짐

<br/>

## Process Concept

### Memory Layout
* `text` : 실행 가능한 코드
* `data` : 전역 변수
* `heap` : 동적 할당 메모리 공간
* `stack` : 함수 호출 시 로컬 변수, 파라미터 등에 사용되는 임시 공간
* text와 data 영역은 고정된 크기, stack과 heap 영역은 확장 및 축소 가능

### Process State
* `new` : 프로세스가 생성됨
* `ready` : 프로세스가 프로세서에 할당되기를 대기
* `running` : 프로세스의 명령어가 실행 중
* `waiting` : 프로세스가 이벤트의 동작을 대기
* `terminated` : 프로세스가 종료됨

### PCB (Process Control Block)
* 프로세스와 관련된 정보를 포함
    * 프로세스의 메모리, IO, 스케줄링 등 실행을 위한 모든 정보를 포함함
* 프로세스 상태, PC, 레지스터 상태 등

### Threads?
* 여러 개의 CPU 코어를 이용해 한 프로세스 내에서 여러 작업을 병렬로 수행 가능
* 예를 들어, 워드 프로세스에서 스레드 1은 사용자 입력을 받고, 스레드 2는 철자 검사를 하는 등
* 스레드를 지원하기 위해 **PCB**가 스레드의 정보를 포함하도록 확장

<br/>

## Process Scheduling
* 코어에서는 한 번에 하나의 프로세스(스레드)만 실행 가능
* 여러 프로세스(스레드)가 동시에 실행될 때, 자원을 할당하는 순서를 정하는 알고리즘!
* 스케줄링의 목적
    * 항상 프로세스가 실행되어 CPU 활용률을 높임
    * 프로세스 간 자주 switch해 사용자가 프로그램과 상호작용할 수 있어야 함
* IO-bound, CPU-bound 고려해 스케줄
    * `IO-bound` : 프로세스가 IO 동작에 더 많은 시간을 소요
    * `CPU-bound` : 프로세스가 CPU 계산에 더 많은 시간을 소요
* 리눅스의 경우 C struct를 통해 PCB를 표현하고, 이중 연결 리스트로 모든 실행 중인 프로세스의 PCB를 유지함

### Scheduling Queues
#### ready queue
* 프로세스가 시스템에 진입 시 레디 큐에 배치
* 연결 리스트 방식으로 구성. 각 PCB가 다음 PCB에 대한 포인터를 가짐


#### wait queue
* 인터럽트 되거나, 이벤트(IO)를 기다려야 하는 상황인 프로세스
* 대기 중인 이벤트가 완료되면 프로세스를 다시 레디 큐에 배치

### CPU Scheduling
* cpu가 준비되면 레디 큐에서 프로세스 하나를 골라 자원 할당 및 실행
* CPU-bound 프로세스라 하더라도 계속 실행되지 않고 **주기적**으로 다른 프로세스로 **switch**
* 주기적인 switch 통해 사용자가 여러 프로그램과 동시에 상호작용 가능

#### swapping
* 다중화의 정도가 너무 높으면 성능이 떨어질 수 있음
    * 많은 프로세스를 관리하는 데 CPU 자원 소요
    * CPU 스케줄링 소요 시간이 커짐
    * 많은 프로그램이 적재되어 메모리를 효율적으로 사용할 수 없음
* 프로세스를 메모리에서 디스크로 내보내 다중화 정도를 낮춤

### Context Switch
* 인터럽트가 발생해 커널 루틴을 실행하거나, 스케줄러에 의해 다른 프로세스로 전환될 때
* 현재 실행 중이던 프로세스의 상태 정보를 PCB에 저장해야 함
    1. 현재 실행 중인 프로세스의 상태를 PCB에 저장
    2. 새 프로세스의 상태를 PCB에서 가져옴

<br/>

## Process Operations
### 프로세스 생성
* 프로세스가 실행 중 새로운 자식 프로세스를 생성할 수 있음
* `pid` : 프로세스를 식별하기 위한 unique ID
* linux의 경우 systemd가 모든 프로세스의 조상

#### parent-child process co-op
* 생성된 자식 프로세스는 cpu, 메모리, 파일, IO 등 자원이 필요함
    1. OS로부터 직접 자원 할당
    2. 부모 프로세스의 자원을 공유
* 부모, 자식 프로세스의 실행 방법
    1. 병렬로 동시에 실행
    2. 부모가 자식이 종료할 때까지 대기
* 부모, 자식 프로세스의 주소 공간
    1. 자식이 부모의 복제본 (같은 프로세스, 같은 주소 공간)
    2. 새로운 프로그램을 자식으로 메모리로 적재

#### UNIX process creation

### Process Termination
1. 마지막 문장을 실행하고 `exit()` 시스템 콜해 프로세스 삭제
    * 종료 후 자원을 반환하고 `wait()` 중인 부모 프로세스에 상태값을 반환
2. 부모 프로세스가 자식의 pid를 통해 자식 프로세스를 종료
3. 사용자가 오작동하는 프로세스를 kill

#### when parent kills child process
1. 자식이 자원을 과도하게 사용하는 경우
2. 자식의 작업이 더이상 필요하지 않을 경우
3. 부모 프로세스가 exit되는 경우 자식 프로세스를 허용하지 않을 때

#### Zombie Process
* 종료되었으나 아직 부모가 `wait()` 호출하지 않은 프로세스
* 부모가 wait 호출 이후 PID와 프로세스 테이블 항목이 해제됨

#### Orphan Process
* 부모가 `wait()` 호출하지 않고 종료된 자식 프로세스
* `systemd` 등을 새로운 부모로 지정해 주는 방식으로 해결

<br/>

## Inter-Process Communication (IPC)
* 프로세스가 다른 프로세스와 영향을 주고 받으며 협력
    * 프로세스 간 같은 정보를 공유해 사용
    * 같은 태스크를 분할해 병렬로 수행하며 성능을 향상
    * 각 프로세스를 모듈처럼 사용해 큰 태스크를 모듈화 처리

<br/>

## Shared Memory IPC
* 프로세스 간 공유하는 메모리 영역을 읽고 쓰며 통신

### pros and cons
* 공유 메모리 영역을 만들 때만 시스템 콜이 필요. 이후 통신은 일반적인 메모리 접근과 같아 **성능이 좋음**

### operation
* 메모리를 공유하고자 하는 프로세스가 공유 메모리 세그먼트 생성
* 공유하기를 원하는 다른 프로세스들은 세그먼트를 자신의 주소 공간에 추가
* 공유 메모리의 데이터 형식 등은 OS가 아닌 프로세스의 주관
    * 프로세스 자체에서 같은 메모리 위치에 동시에 쓰지 않도록 해야 함

<br/>

## Message Passing IPC
* 프로세스 간 메시지를 교환하며 통신

### pros and cons
* **작은 양**의 데이터를 교환하기에 유리함. conflict 발생하지 않음
* **분산 시스템**에서의 구현이 용이함
* **시스템 콜**을 이용해 메시지를 교환해 공유 메모리 방식에 비해 **느림**

### Direct vs Indirect
#### direct communication
* 송신, 수신 프로세스가 상대의 이름을 명시해야 통신이 가능한 경우
* 프로세스 ID를 하드코딩해 명시해야 하므로 모듈화가 제한됨
    * pid 변경 시 다른 모든 프로세스를 검사해야 하는 등

#### indiret communication
* 프로세스가 보낸 메시지를 메일박스에 저장
* 프로세스들이 공통 메일 박스를 가질 경우 통신 가능
    * 두 개 이상의 프로세스가 연관되어 통신 가능

### Synchronization
* `blocking send` : 수신될 때까지 송신 프로세스가 대기
* `blocking recv` : 메시지가 가용할 때까지 수신 프로세스가 대기
* `non-blocking send` : 메시지를 송신한 뒤 자신의 작업을 수행
* `non-blocking recv` : 대기하지 않고 올바른 메시지를 받거나 null을 수신

### Buffering
* 교환한 메시지는 임시 큐에 저장됨
* `zero capacity`
    * 메시지를 임시 큐에 저장할 수 없음
    * 전송자는 수신자가 메시지를 처리할 때까지 반드시 block
* `bounded capacity`
    * 메시지 큐가 꽉 찬 경우 전송자가 block
* `unbounded capacity`
    * 메시지를 저장하는 큐가 무한대로 크기가 큼
    * 전송자는 절대 block되지 않음