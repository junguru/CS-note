# IO System

## IO Hardware

### Memory Mapped IO
* `IO instruction`
    * IO를 위한 특별한 명령어로, 호출 시 버스를 통해 장치 레지스터를 조작
* `memory mapped IO`    
    * 디바이스 컨트롤러의 레지스터가 프로세서의 주소 공간으로 **매핑**됨
    * 물리 메모리의 매핑된 주소에 대해 읽기/쓰기 수행해 IO 동작
    * 주로 data-in, data-out, status, control 레지스터 네 가지로 구성됨

### Polling
* CPU가 주기적으로 장치가 준비되었는지 확인하는 신호(poll) 보냄
* 폴링 주기가 느리다면 정보가 손실될 수 있음
    * 키보드 입력을 받는 버퍼가 가득차 입력이 손실되는 등
* 장치가 충분히 빠르지 않다면 폴링에 CPU가 낭비되므로 인터럽트를 통한 IO가 더 좋음

### Interrupt
1. 시스템 콜을 통한 IO 요청
2. 디바이스 드라이버가 디바이스 컨트롤러에게 명령을 보냄
3. 디바이스 컨트롤러가 명령을 수행
4. 작업 완료 후 인터럽트 신호를 Interrupt Request Line 통해 전송
5. 인터럽트를 받은 뒤 현재 프로세스 상태 저장 후 ISR로 전환
6. ISR 수행 후 인터럽트 야기시킨 프로세스로 돌아가 작업 재개
* 장치 IO, 소프트웨어 에러, 커널 루틴 실행, 우선순위 별 인터럽트 등 다양한 용도로 보편적인 활용
* 인터럽트 IO를 효율적으로 처리하는 것이 시스템 성능에 큰 영향을 미침

### Direct Memory Access
* 디스크와 같이 대규모로 데이터를 주고 받는 IO 수행 시 매 바이트마다 인터럽트 처리하는 것은 비효율적임
* 대신 DMA 컨트롤러를 통해 CPU의 도움 없이 메모리에 IO 전송 수행
* IO 전송 대상 메모리는 커널 주소 공간이어야 함
    * 유저 메모리는 유저 프로세스가 수정할 수 있으므로 불안전
    * 커널 공간에 전송을 받고 유저 공간으로 내용을 옮기는 것은 비효율적임
    * 대신 유저 공간에 대해 memory-mapped IO 수행

### Device Controller vs Device Driver
* `device controller`
    * 장치의 동작을 제어하는 하드웨어
    * 로컬 버퍼, 특수 목적 레지스터를 가짐
* `device driver`
    * 커널 영역에 적재되어 장치의 동작을 제어하는 소프트웨어
    * IO 요청 시 디바이스 드라이버로 문맥 전환되어 요청을 디바이스 컨트롤러로 전송함

<br/>
<br/>

## Application IO Interface
* 인터페이스를 통한 캡슐화, 추상화로 장치의 타입과 동작을 몰라도 접근할 수 있게 됨
    * 동일한 인터페이스 명령을 받아 **디바이스 드라이버**가 장치 타입 별로 다른 동작을 수행하도록 구현
    * 장치가 추가되어도 OS가 제공하는 인터페이스는 동일하므로 OS 유지보수가 용이
* 크게 디바이스는 다음으로 분류됨
    * block IO
    * character-stream IO
    * memory-mapped file access
    * network sockets
* 사용자 및 커널 프로그램은 장치 인터페이스가 제공하는 기능을 이용해 프로그램

<br/>
<br/>

## Kernel IO Interface
* 커널 IO 서브시스템을 통해 IO 스케줄링, 캐싱 등 IO와 관련된 기능 수행

### IO Scheduling
* 각 장치마다 대기 큐를 유지해 스케줄링
    1. IO 요청 시 해당 장치의 대기 큐에 요청을 배치
    2. 시스템의 성능을 향상하도록 IO 요청의 순서를 재배치
    3. 순서에 맞게 IO 동작을 수행

### Buffering
1. 데이터 송신자와 수신자 간 속도 차이를 완충
    * 인터넷으로부터 파일을 다운로드해 SSD에 저장하는 경우
    * 네트워크의 속도가 디스크의 속도보다 느리므로 버퍼에 먼저 채움
2. 장치가 서로 다른 크기 단위로 데이터를 전송하는 경우
    * 네트워킹에서 패킷을 분할해 전송하고 다시 병합하는 등
3. copy semantics
    * 앱의 버퍼에 있는 데이터를 IO로 작성할 때 버퍼의 내용을 수정해도 문제 없도록
    * 먼저 커널 버퍼로 옮긴 뒤 커널 버퍼에서 전송하는 등 방법

### Caching
* 메모리 영역의 일부를 버퍼로 캐시처럼 사용해 IO 스케줄링을 효율적으로 수행
* `delaying write` : 버퍼에 디스크에 작성할 내용을 무은 뒤 한번에 작성

### Spooling and Device Reservation
* 프린터 등 연속된 데이터 스트림만 출력할 수 있는 장치
* 각 프로세스의 출력 요청을 spool 파일에 저장한 뒤 하나씩 스케줄해 출력
* `device reservation`
    * 프린터 등 장치는 여러 프로세스의 동시 접근을 잘 처리하지 못함
    * 장치를 한번에 한 프로세스에게 할당하거나 프로세스에서 장치가 가용할때까지 대기하는 시스템 콜 지원 등

### Error Handling
* 장치 컨트롤러 하드웨어 결함과 같은 영구적인 문제가 아닌 한, 에러 처리가 가능함
* IO 시스템 콜이 호출의 상태를 1비트 값으로 리턴함
* read() 실패 시 다시 수행하거나, send() 실패 시 resend() 등

### IO Protection
* 우저 프로그램이 악의적으로 허용되지 않은 IO를 수행하는 것을 방지
* 모든 IO 동작을 previleged 명령어로 시스템 콜 호출해야 하도록 설정
* memory mapped IO 혹은 IO 포트 위치 또한 보호되어야 함

### Kernel Data Structure
* 파일, 장치 등의 상태를 저장, 관리하는 자료 구조를 커널이 관리함
* 같은 인터페이스 동작이더라도 장치 타입에 따라 다른 자료구조를 다른 방법으로 이용함
    * 객체지향 (같은 메서드를 다르게 구현) 방법으로 해결

<br/>
<br/>

## IO Request to HW Operation
* 커널 서브 루틴을 호출하거나 커널 내 메시지 전송 등을 통해 IO 요청을 전달
* IO 장치들에 대해 요청을 전달하는 방법은 general 하므로, 새 장치가 추가되어도 커널을 다시 컴파일하지 않아도 됨

### IO Procedure
1. 시스템 콜을 통해 IO 요청
2. 커널 버퍼 캐시에서 데이터가 이미 가용하다면 결과를 프로세스에 리턴 후 종료
3. 프로세스를 대기 큐로 이동 후 IO 요청을 스케줄. 요청을 디바이스 드라이버로 전송
4. 디바이스 드라이버가 스케줄링, 데이터 송수신 등 작업 위한 커널 버퍼 공간 할당
5. 작업 완료 후 인터럽트 생성
6. ISR에서 필요한 데이터 저장 후 디바이스 드라이버에게 신호
7. 디바이스 드라이버가 신호를 받고, IO 요청의 상태 등 결정 후 커널 IO 서브시스템에 신호
8. 전달된 데이터 및 리턴 코드를 요청한 프로세스에 반환
9. IO 요청한 프로세스를 재개

<br/>
<br/>

## Streams
* 스트림을 통해 디바이스 드라이버와 프로세스를 연결
* 프로세스와 연결된 스트림 헤드, 드라이버와 연결된 스트림 엔드, 그 사이의 스트림 모듈로 구성
* 각 스트림 모듈은 read 큐와 write 큐로 구성됨
* 인접 모듈 간 메시지 패싱을 통해 데이터 송수신
* 스트림 IO는 **비동기**
    * 스트림 헤드를 읽고 쓸 때는 제외 (버퍼가 비거나 데이터 가용할 때까지 기다릴 것임)
* `ioctl` 통해 스트림에 스트림 모듈을 삽입할 수 있음
* 스트림을 통해 모듈화되고 점진적으로 디바이스 드라이버나 네트워크 프로토콜을 작성할 수 있음

<br/>
<br/>

## IO Performance
* IO 수행은 시스템의 성능에 크게 영향을 미침
    * 프로세스 상태 저장 및 ISR로 문맥 전환
    * 메모리 버스를 통한 데이터 전송
    * 커널 영역과 프로세스 영역 간 데이터 전송 등
* `programmed io`
    * IO 대기하는 데에 사이클이 많이 소요되지 않는다면 인터럽트 기반 IO보다 성능이 좋을 수 있음
* IO 수행의 인터럽트 문맥 전환 부담을 줄이기 위한 하드웨어 추가 사용 가능
    * front-end processor, I/O channel 등
* 효율적이고 안전한 IO 기능의 구현을 어떤 수준으로 할 것인지
    * 앱 수준, 커널 수준, 하드웨어 수준