# Index
* 데이터에 대한 접근 속도 향상을 위함
* `search key` : 레코드를 탐색하기 위한 속성
* `index entry` : search key와 상응하는 레코드의 주소
* 인덱스 파일의 크기가 원래 테이블 파일의 크기보다 보통 작음

<br/>

## 인덱스 성능 평가
* 인덱스를 이용한 데이터 접근 시간
* 데이터 삽입, 삭제 시 인덱스 수정 시간
* 인덱스 파일의 크기
* 쿼리의 타입에 따라 다르게 평가
    * point / range / partial match 등

<br/>

## Ordered Indices
* 인덱스 엔트리가 탐색 키를 기준으로 정렬되어 저장

### clustering index (primary index)
* sequentially orderd file에서 인덱스의 순서가 파일에 정렬된 데이터의 순서와 같은 경우
* 즉, 블록 내에서 레코드가 정렬됨
* 주로 PK가 인덱스의 탐색 키
* 테이블 당 하나만 가질 수 있음
* 데이터가 정렬되어 저장되므로, 범위 질의에 유리

### non-clustering (secondary) index
* 인덱스의 순서와 파일에 저장된 레코드의 순서가 다른 경우
* 즉, 레코드가 정렬되지 않음
* 범위 질의 시 많은 IO 발생할 수 있음
* 여러 개 가질 수 있음. 언제든 생성/삭제 가능
* 반드시 dense 해야 함 - 레코드의 정렬 순서와 다르기 때문

### dense index
* 존재하는 모든 키 값에 대해 인덱스 레코드 존재
* 탐색 키가 같은 첫 레코드에 대한 포인터
* 탐색 키 기준으로 레코드가 정렬되어 있어야 함
* 레코드의 위치 탐색에 유리

### sparse index
* 존재하는 탐색 키 값 중 일부에 대해 인덱스 레코드 존재
* 탐색 키 기준으로 레코드가 정렬되어 있어야 함
* 레코드 위치 탐색 시 밀집 인덱스에 비해 느림
    1. 검색 키보다 작거나 같은 키 중 가장 큰 키의 인덱스 엔트리 찾기
    2. 포인터를 따라간 뒤 원하는 레코드 찾을 때까지 디스크 탐색
* 밀집 인덱스에 비해 적은 공간 사용
* 레코드 삽입, 삭제 시 밀집 인덱스보다 유리
* 각 데이터 블록의 첫 레코드의 포인터로 sparse index 구성 시 효율적임
    * 블록 단위로 버퍼로 가져와 작업하기 때문

### multilevel index
* 단일 레벨로 구성 시 인덱스 파일의 크기가 커지는 경우
* 바깥 쪽 인덱스는 안쪽 인덱스에 대한 sparse 인덱스
* 안쪽 인덱스는 데이터에 대한 인덱스

### indexed-sequential file의 단점
* 레코드와 인덱스 엔트리를 관리할 때 많은 오버플로우 블럭이 생성됨
    * 레코드 삭제 시 shift 대신 free space chain 활용
    * 레코드 삽입 시 공간 없을 때 오버플로우 블럭 사용
* 주기적으로 전체 파일 재정렬 필요