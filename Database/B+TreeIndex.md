# B+ Tree Index
* 성능 유지를 위해 파일 전체를 재구성할 필요 없음
* 레코드 삽입, 삭제 시 인덱스를 스스로 재구성함
* 다만, 삽입/삭제 시 오버헤드와 메모리 오버헤드가 추가적으로 존재

<br/>

## Definition
* 로트로부터 리프 노드까지의 거리가 모두 같음
* 내부 노드는 $\lceil n/2 \rceil$에서 $n$개의 자식을 가짐
* 말단 노드는 $\lceil (n-1)/2 \rceil$에서 $n-1$개의 값을 가짐
* 루트 노드
    * 말단 노드가 아니라면 2개 이상의 자식을 가짐
    * 말단 노드라면 0에서 $n-1$개의 값을 가짐

### Node Structure
|$P_1$|$K_1$|$P_2$|...|$P_{n-1}$|$K_{n-1}$|$P_n$|
|--|--|--|--|--|--|--|

* $K_i$는 탐색 키의 값
* $K_1 < K_2 < ... < K_{n-1}$
* $P_i$는 자식에 대한 포인터 혹은 레코드에 대한 포인터

#### Leaf Node
* 레코드에 대한 dense 인덱스
* 왼 쪽 말단 노드의 탐색 키 값이 오른 쪽 말단 노드의 탐색 키 값보다 작음
* $P_i$는 탐색 키가 $K_i$인 레코드 (또는 버켓)에 대한 포인터
* $P_n$이 다음 말단 노드에 대한 포인터

#### Non-Leaf Node
* 말단 노드에 대한 멀티레벨 sparse 인덱스의 역할 수행
* $P_i$가 가리키는 서브트리의 탐색 키 값은 모두 $K_i$보다 작고 $K_{k-1}$보다 크거나 같음

<br/>

## Performance of B+ Tree Index
* 노드 하나의 크기가 블럭 하나의 크기
    * 인덱스도 디스크 파일이므로, 블럭 단위로 접근
    * 노드의 크기가 블럭보다 작은 것은 의미가 없음!
* 트리의 레벨이 대체로 작다
    * 구현 상 모든 노드가 절반 이상의 값을 가지기 때문
    * 최악의 경우 접근하는 인덱스 블럭의 수 (트리의 높이)는 $\lceil \log_{n/2}{K} \rceil$ (모든 노드가 반씩 차 있을 때)
    * 블럭의 크기만큼 노드를 설정 시 차수가 크고, 차수가 큰 로그 취할 시 로그 값은 작음

<br/>

## Queries on B+ Tree
### Search
1. 루트에서부터 탐색 시작
2. 현재 노드에서 탐색 키보다 크거나 캍은 키 $K_i$ 선택
    * 없다면 노드를 맨 오른쪽 자식 노드로 옮김
    * 탐색 키 값과 $K_i$ 값이 같다면 노드를 $P_{i+1}$로 옮김
    * 아니라면 현재 노드를 $P_i$로 옮김
3. 말단 노드에 도달할 때까지 2를 반복
4. 말단 노드에서 탐색 키 값과 같은 $K_i$ 발견 시 $P_i$ 리턴
    * 발견하지 못할 경우 null 리턴

### Range Query
1. clustering 인덱스인 경우
    * 첫 범위 위치의 레코드로부터 순차적으로 디스크 탐색
2. non-clustering 인덱스인 경우
    * 레코드의 순서와 인덱스 순서가 다름
    * 디스크 탐색 비용 추가적으로 많이 발생

### Insertion
1. 삽입하는 탐색 키에 대해 B+ Tree 탐색 수행
2. 탐색된 말단 노드의 자리에 공간이 있다면 (v, pr) 삽입
3. 공간이 없다면 말단 노드를 분할 후 부모로 전파
    * n개의 (키, 포인터) 쌍 중 첫 $\lceil n/2 \rceil$개를 기존 노드로, 나머지를 새 노드로 구성
    * 새 노드를 p, 새 노드의 가장 작은 키가 k일때 (k,p)를 부모 노드에 삽입
    * 부모가 꽉 찼다면 루트까지 올라가며 분할, 전파

### Deletion
1. 삽입하는 탐색 키에 대해 B+ Tree 탐색 수행
2. 말단 노드에서 탐색된 (v, pr)을 제거
3. 제거 후 노드의 (키, 포인터) 수가 B+ Tree 조건보다 작아지는 경우
    * 왼쪽 노드로 현재 노드의 (키, 포인터) 쌍을 병합
    * 기존 노드를 제거 후 부모 노드에서 $(K_{i-1},P_i)$를 제거하는 과정을 재귀적으로 수행
    * 만약 왼쪽 자식과 합했을 때 엔트리가 너무 많다면, 노드를 제거하지 않고 양 쪽의 쌍을 재분배

<br/>

## B+ Tree File Organization
* 말단 노드에 포인터 대신 데이터 레코드를 사용
* 트리의 높이가 커질 수 있음
    * 레코드 하나의 크기가 크다면 노드의 degree가 작아짐
    * 말단 노드가 포인터가 아닌 레코드이기 때문

<br/>

## B Tree Index
* B+ 트리와 달리 탐색 키 값이 한 번만 나타남
* B+ 트리와 달리 내부 노드에 탐색 키 값에 대한 포인터가 존재
* 탐색 시 말단 노드까지 가야 하는 B+ 트리와 달리 내부 노드에서 레코드로 이동 가능
* B+ 트리에 비해 더 적은 수의 노드 사용
* 내부 노드가 포인터를 포함하므로 크기가 크다. 노드의 degree가 작아져 트리의 height 커짐 => 더 많은 디스크 접근
* 구현이 B+ 트리에 비해 복잡


<br/>

## Issues on Indexing
* 레코드 업데이트 하지 않아도 위치가 바뀌는 경우가 존재
    * 다른 레코드 삽입/삭제, bad-sector 등 본인의 위치가 바뀜
    * 레코드ID를 통해 주소를 알 수 있는 indirection 맵을 유지
    * 레코드 포인터 대신 레코드ID를 B+ Tree에서 나타냄
    * 위치 갱신 측면에서는 유리하지만, 탐색 시 레코드ID를 통해 한번 더 탐색 수행해야 함

<br/>

## Bulk Loading & Bottom-Up Build
* 이미 존재하는 테이블에 대한 인덱스 구성
* 레코드 하나씩 인덱스를 삽입하면
    * 트리가 커질 수 있음
    * 시간이 오래 걸림 (각 삽입이 노드의 분할 필요할 수 있음)
* 대신 bottom up
    1. 레코드를 정렬 (external sort)
    2. 말단 노드 계층부터 시작해 루트까지 올라가며 계층별로 노드 구성

<br/>

## Indexing on Flash Memory
* 랜덤 접근의 비용이 디스크에 비해 낮음
* 하지만 write 위해 erase 필요하므로 (in-place write 불가능) 여전히 인덱싱이 유효함
* page earse 수를 줄이는 bulk loading이 유효함
* 플래시 메모리에 적합하도록 write의 수를 줄이는 **write-optimzed tree** 구조 사용